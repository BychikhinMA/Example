from multiprocessing import Condition


a = 10
b = 20

print('Первый пример')

print(a == b)   # False
print(a != b)   # True
print(a > b)    # False
print(a < b)    # True
print(a >= b)   # False
print(a <= b)   # True
print('___')
# Первый пример
# Сравнивать можно не только числав но и буквы

print('Второй пример')

a = 'абвг'
b = 'абв'

print(a == b)   # False
print(a != b)   # True
print(a > b)    # False
print(a < b)    # True
print(a >= b)   # False
print(a <= b)   # True
print('___')
# Второй пример

print('Третий пример')

# Для строк можно проверить вхождение одной строки в другую, для этого используется оператор in:
a = 'абвг'
b = 'абв'
print(a in b)   # False (Строка а не входит в строку b)
print(b in a)   # True (Строка b входит в строку а)
print('___')

print('Четвертый пример')

# Операторы сравнения можно использовать не только при печати,
# но и передавать результат сравнения в переменную. Затем мы сможем использовать эту переменную в коде:
result = b in a

print(result)   # True 
print('___')

print('Пятый пример')

# Логические операторы уточняют условие сравнения.
# Допустим, у нас есть некоторое число value и мы хотим проверить, 
# что это число находится в диапазоне от 10 до 50:

value = 15
result = value >= 10 and value <= 50
print(result)   # True

# Сравнение на диапазоны достаточно частая задача, поэтому такую запись в Python можно сократить:

value = 15 
result = 10 <= value <= 50 
print(result)   # True
print('___')

print('Шестой пример')

# Выражение сравнения может быть сколько угодно сложным, 
# в нем может использоваться любое количество любых операторов. 
# Проверим, что буква б входит в строку my_string и количество вхождений больше 3:

my_string = 'Аббб'
result = 'б' in my_string and my_string.count('б') > 3
print(result)   # False
print('___')

print('Седьмой пример')

# Добавим к шестому примеру еще одно условие 'ИЛИ'

my_string = 'Аббб'
result = 'б' in my_string and my_string.count('б') > 3 or my_string[0] == 'А'
print(result)   # True
print('___')

print("Конструкция оператора 'if'")

# if Condition_1: #   если условие_1:
    #   code, if condition_1 == True    # код, если выполняется условие_1
#elif Condition_2:   #   если условие_2
    #   code, if condition_2 == True    # код, если выолняется условие_2
#Else:   #   Иначе:
    #   code, if not condition_1 and not conditin_2 # код, если ни одно условие не выполняется

print('Пример 1')

a = 20  # Область основной программы, потому что отступов нет
b = 20  # Область основной программы

if a == b:  # Область основной программы 
    print('Число a равно числу b')  # Область оператора if
print('___')

print('Пример 2')

today = 'Пятница'
direction = ''

if today.lower() == 'пятница':
    direction = 'в клуб'

print('Сегодня', today.lower(), 'поэтому мы идем', direction)
print('___')

print('Пример 3')

a = 20
b = 20

result = ''
if a == b:
    result = 'Число a равно числу b'    

# А что будет, если а не будет равно b? 
# Тогда будет ошибка - условие не выполнится и переменная result не будет создана,
# потому что программа просто напросто не зайдет в эту ветку.
# Поскольку переменной result не будет, то функция print(result)

print(result)
# В ошибке говорится: “Ошибка имени: имя 'result' не определено”.
# Это очень частая ошибка среди разработчиков. 
# Нужно запомнить правило - переменные всегда нужно определять в основном теле программы.
# Нельзя определять переменные во вложенных блоках (внутри условий или внутри циклов).
# Best practice: всегда создавай переменные до условий
print('___')

print('Пример 4')

a = 20
b = 201

result = ''

if a == b:
    result = 'Число a равно числу b'
else:
    result = 'Число a НЕ равно числу b'

print(result)
print('___')

print('Сокращенная проверка')
# Оператор if поддерживает сокращенные проверки. 
# Предположим, у нас есть переменная is_available типа bool. 
# Она может принимать только 2 значения: либо True либо False, 
# тогда в операторе if нам не обязательно писать == True, 
# чтобы проверить равна ли переменная значению True, достаточно просто написать if is_available

print('Пример 1')

is_available = True 
if is_available:
    print('Доступ есть')
else:
    print('Доступа нет')

print('___')

print('пример 2')

my_string = ''

if len(my_string) >0:
    print('Строка содержит символы')
else:
    print('Строка не содержит символы')

# Такие условия можно сократить:

my_string = ''

if my_string:
    print('Строка содержит символы')
else:
    print('Строка пустая')

# Такое условное выражение можно сократить и написать просто if my_string. 
# Тогда оператор if будет сам проверять пустая строка или нет. 
# Если строка содержит символы, то выражение if my_string будет равно True, 
# если строка пустая, то False:
print('___')

print('Пример 3')

# Тоже самое работает и с числами: число 0 воспринимается как False при сравнении:

my_number = 0

if my_number:
    print('Число не равно 0')
else:
    print('Число равно 0')

print('___')

print('Пример 4')

# Когда нам требуется проверить заполненность какого-то значения, 
# часто используется логический оператор not - не. 
# Оператор not переворачивает результат выражения - из True делает False, а из False делает True: 

money = 0

if not money:
    print('Печально :(')
else:
    print('Пойду в бар!')

print('___')

print('Best practice - конкурентность вычислений')

print('Пример 1')


my_string = 'аб!вг'

if my_string[2] == '!':
    print(my_string)
else:
    print('Ничего не найдено')

print('___')

print('Пример 2')

my_string = ''

if my_string and my_string[2] == '!':
    print(my_string)
else:
    print('Ничего не найдено')


print('Тернарный оператор if')

# В Python существует лаконичная замена оператора if - тернарный оператор if. 
# Тернарный оператор if - это точно такой же if только записанный в одну строку.
#Синтаксис тернарного оператора if:

#result = value_if_true if condition else value_if_false

temperature = 0

feeling = 'Холодно' if temperature < 0 else 'Нормально'

print(feeling)